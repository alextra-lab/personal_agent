"""Parser for text-based tool calls from reasoning models.

Reasoning models like DeepSeek-R1 that don't support native function calling
often generate tool requests in text format. This module provides parsing logic
to extract and normalize these text-based tool calls into the standard ToolCall format.

Supported formats:
1. [TOOL_REQUEST]{"name":"tool_name","arguments":{...}}[END_TOOL_REQUEST]
2. <tool_call>{"name":"tool_name","arguments":{...}}</tool_call>
3. Tool: tool_name(arg1=value1, arg2=value2)
4. [tool_name, {"arg":"value"}]  (common malformed fallback from some models)
"""

import json
import re
from typing import Any

from personal_agent.llm_client.types import ToolCall
from personal_agent.telemetry import get_logger

log = get_logger(__name__)


def _parse_relaxed_json_object(raw: str) -> dict[str, Any] | None:
    """Best-effort parse of a JSON object with trailing noise.

    Some models emit bracket fallback calls with an extra closing brace/bracket
    suffix, e.g. `{"messages":[...}]}}]`.
    """
    candidate = raw.strip()
    while candidate:
        try:
            data = json.loads(candidate)
            if isinstance(data, dict):
                return data
            return None
        except json.JSONDecodeError:
            candidate = candidate[:-1].rstrip()
    return None


def _extract_bracket_fallback_calls(content: str) -> list[tuple[str, str]]:
    """Extract `[tool_name, {json}]` chunks from free-form model output."""
    extracted: list[tuple[str, str]] = []
    idx = 0
    n = len(content)

    while idx < n:
        start = content.find("[", idx)
        if start == -1:
            break

        j = start + 1
        while j < n and content[j].isspace():
            j += 1

        name_start = j
        while j < n and (content[j].isalnum() or content[j] == "_"):
            j += 1
        tool_name = content[name_start:j]
        if not tool_name:
            idx = start + 1
            continue

        while j < n and content[j].isspace():
            j += 1
        if j >= n or content[j] != ",":
            idx = start + 1
            continue
        j += 1

        while j < n and content[j].isspace():
            j += 1
        if j >= n or content[j] != "{":
            idx = start + 1
            continue

        brace_start = j
        depth = 0
        in_string = False
        escape = False
        while j < n:
            ch = content[j]
            if in_string:
                if escape:
                    escape = False
                elif ch == "\\":
                    escape = True
                elif ch == '"':
                    in_string = False
            else:
                if ch == '"':
                    in_string = True
                elif ch == "{":
                    depth += 1
                elif ch == "}":
                    depth -= 1
                    if depth == 0:
                        break
            j += 1

        if j >= n or depth != 0:
            idx = start + 1
            continue

        args_json = content[brace_start : j + 1]
        extracted.append((tool_name, args_json))
        idx = j + 1

    return extracted


def parse_text_tool_calls(content: str, trace_id: str | None = None) -> list[ToolCall]:
    """Parse tool calls from text content generated by reasoning models.

    This function attempts multiple parsing strategies to extract tool calls
    from free-form text output. It handles various formats that reasoning models
    might use to indicate tool invocations.

    Args:
        content: Text content from model response.
        trace_id: Optional trace ID for logging.

    Returns:
        List of ToolCall objects extracted from text.
    """
    tool_calls: list[ToolCall] = []

    # Strategy 1: [TOOL_REQUEST]{...}[END_TOOL_REQUEST]
    # Note: Some models incorrectly close with [END_TOOL_RESULT] â€” accept both to be robust.
    pattern_1 = r"\[TOOL_REQUEST\](.*?)\[(?:END_TOOL_REQUEST|END_TOOL_RESULT)\]"
    matches = re.findall(pattern_1, content, re.DOTALL)
    for match in matches:
        try:
            data = json.loads(match.strip())
            tool_calls.append(
                ToolCall(
                    id=f"text_tool_{len(tool_calls)}",
                    name=data.get("name", ""),
                    arguments=json.dumps(data.get("arguments", {})),
                )
            )
            log.debug(
                "parsed_text_tool_call",
                format="TOOL_REQUEST",
                tool_name=data.get("name"),
                trace_id=trace_id,
            )
        except json.JSONDecodeError as e:
            log.warning(
                "failed_to_parse_tool_request",
                format="TOOL_REQUEST",
                match=match[:100],
                error=str(e),
                trace_id=trace_id,
            )

    # Strategy 2: <tool_call>{...}</tool_call>
    pattern_2 = r"<tool_call>(.*?)</tool_call>"
    matches = re.findall(pattern_2, content, re.DOTALL)
    for match in matches:
        try:
            data = json.loads(match.strip())
            tool_calls.append(
                ToolCall(
                    id=f"text_tool_{len(tool_calls)}",
                    name=data.get("name", ""),
                    arguments=json.dumps(data.get("arguments", {})),
                )
            )
            log.debug(
                "parsed_text_tool_call",
                format="tool_call_tag",
                tool_name=data.get("name"),
                trace_id=trace_id,
            )
        except json.JSONDecodeError as e:
            log.warning(
                "failed_to_parse_tool_request",
                format="tool_call_tag",
                match=match[:100],
                error=str(e),
                trace_id=trace_id,
            )

    # Strategy 3: Tool: tool_name(arg1=value1, arg2=value2)
    # This is a simplified parser for function-style tool calls
    pattern_3 = r"Tool:\s*(\w+)\((.*?)\)"
    matches = re.findall(pattern_3, content, re.DOTALL)
    for tool_name, args_str in matches:
        try:
            # Parse key=value arguments
            arguments: dict[str, Any] = {}
            if args_str.strip():
                # Split by commas not inside quotes
                arg_pairs = re.findall(
                    r'(\w+)=([^,]+(?:,(?![^"]*"[^"]*(?:"[^"]*"[^"]*)*$))?)', args_str
                )
                for key, value in arg_pairs:
                    # Remove quotes if present
                    value = value.strip().strip('"').strip("'")
                    arguments[key.strip()] = value

            tool_calls.append(
                ToolCall(
                    id=f"text_tool_{len(tool_calls)}",
                    name=tool_name,
                    arguments=json.dumps(arguments),
                )
            )
            log.debug(
                "parsed_text_tool_call",
                format="function_style",
                tool_name=tool_name,
                trace_id=trace_id,
            )
        except Exception as e:
            log.warning(
                "failed_to_parse_tool_request",
                format="function_style",
                tool_name=tool_name,
                args_str=args_str[:100],
                error=str(e),
                trace_id=trace_id,
            )

    # Strategy 4: [tool_name, {"arg":"value"}]
    # Some models emit this instead of required [TOOL_REQUEST] JSON envelope.
    for tool_name, args_json in _extract_bracket_fallback_calls(content):
        parsed_args = _parse_relaxed_json_object(args_json)
        if parsed_args is None:
            log.warning(
                "malformed_text_tool_call_detected",
                format="bracket_fallback",
                tool_name=tool_name,
                args_preview=args_json[:160],
                trace_id=trace_id,
            )
            continue

        tool_calls.append(
            ToolCall(
                id=f"text_tool_{len(tool_calls)}",
                name=tool_name,
                arguments=json.dumps(parsed_args),
            )
        )
        log.debug(
            "parsed_text_tool_call",
            format="bracket_fallback",
            tool_name=tool_name,
            trace_id=trace_id,
        )

    if tool_calls:
        log.info(
            "extracted_text_tool_calls",
            count=len(tool_calls),
            tools=[tc["name"] for tc in tool_calls],
            trace_id=trace_id,
        )

    return tool_calls
