"""Parser for text-based tool calls from reasoning models.

Reasoning models like DeepSeek-R1 that don't support native function calling
often generate tool requests in text format. This module provides parsing logic
to extract and normalize these text-based tool calls into the standard ToolCall format.

Supported formats:
1. [TOOL_REQUEST]{"name":"tool_name","arguments":{...}}[END_TOOL_REQUEST]
2. <tool_call>{"name":"tool_name","arguments":{...}}</tool_call>
3. Tool: tool_name(arg1=value1, arg2=value2)
"""

import json
import re
from typing import Any

from personal_agent.llm_client.types import ToolCall
from personal_agent.telemetry import get_logger

log = get_logger(__name__)


def parse_text_tool_calls(content: str, trace_id: str | None = None) -> list[ToolCall]:
    """Parse tool calls from text content generated by reasoning models.

    This function attempts multiple parsing strategies to extract tool calls
    from free-form text output. It handles various formats that reasoning models
    might use to indicate tool invocations.

    Args:
        content: Text content from model response.
        trace_id: Optional trace ID for logging.

    Returns:
        List of ToolCall objects extracted from text.
    """
    tool_calls: list[ToolCall] = []

    # Strategy 1: [TOOL_REQUEST]{...}[END_TOOL_REQUEST]
    # Note: Some models incorrectly close with [END_TOOL_RESULT] â€” accept both to be robust.
    pattern_1 = r"\[TOOL_REQUEST\](.*?)\[(?:END_TOOL_REQUEST|END_TOOL_RESULT)\]"
    matches = re.findall(pattern_1, content, re.DOTALL)
    for match in matches:
        try:
            data = json.loads(match.strip())
            tool_calls.append(
                ToolCall(
                    id=f"text_tool_{len(tool_calls)}",
                    name=data.get("name", ""),
                    arguments=json.dumps(data.get("arguments", {})),
                )
            )
            log.debug(
                "parsed_text_tool_call",
                format="TOOL_REQUEST",
                tool_name=data.get("name"),
                trace_id=trace_id,
            )
        except json.JSONDecodeError as e:
            log.warning(
                "failed_to_parse_tool_request",
                format="TOOL_REQUEST",
                match=match[:100],
                error=str(e),
                trace_id=trace_id,
            )

    # Strategy 2: <tool_call>{...}</tool_call>
    pattern_2 = r"<tool_call>(.*?)</tool_call>"
    matches = re.findall(pattern_2, content, re.DOTALL)
    for match in matches:
        try:
            data = json.loads(match.strip())
            tool_calls.append(
                ToolCall(
                    id=f"text_tool_{len(tool_calls)}",
                    name=data.get("name", ""),
                    arguments=json.dumps(data.get("arguments", {})),
                )
            )
            log.debug(
                "parsed_text_tool_call",
                format="tool_call_tag",
                tool_name=data.get("name"),
                trace_id=trace_id,
            )
        except json.JSONDecodeError as e:
            log.warning(
                "failed_to_parse_tool_request",
                format="tool_call_tag",
                match=match[:100],
                error=str(e),
                trace_id=trace_id,
            )

    # Strategy 3: Tool: tool_name(arg1=value1, arg2=value2)
    # This is a simplified parser for function-style tool calls
    pattern_3 = r"Tool:\s*(\w+)\((.*?)\)"
    matches = re.findall(pattern_3, content, re.DOTALL)
    for tool_name, args_str in matches:
        try:
            # Parse key=value arguments
            arguments: dict[str, Any] = {}
            if args_str.strip():
                # Split by commas not inside quotes
                arg_pairs = re.findall(
                    r'(\w+)=([^,]+(?:,(?![^"]*"[^"]*(?:"[^"]*"[^"]*)*$))?)', args_str
                )
                for key, value in arg_pairs:
                    # Remove quotes if present
                    value = value.strip().strip('"').strip("'")
                    arguments[key.strip()] = value

            tool_calls.append(
                ToolCall(
                    id=f"text_tool_{len(tool_calls)}",
                    name=tool_name,
                    arguments=json.dumps(arguments),
                )
            )
            log.debug(
                "parsed_text_tool_call",
                format="function_style",
                tool_name=tool_name,
                trace_id=trace_id,
            )
        except Exception as e:
            log.warning(
                "failed_to_parse_tool_request",
                format="function_style",
                tool_name=tool_name,
                args_str=args_str[:100],
                error=str(e),
                trace_id=trace_id,
            )

    if tool_calls:
        log.info(
            "extracted_text_tool_calls",
            count=len(tool_calls),
            tools=[tc["name"] for tc in tool_calls],
            trace_id=trace_id,
        )

    return tool_calls
