"""Governance integration for MCP tools.

This module manages auto-discovery and configuration of MCP tools
in the governance config file (config/governance/tools.yaml).
"""

from datetime import datetime
from typing import Any, Literal

import yaml

from personal_agent.config import settings
from personal_agent.telemetry import get_logger

log = get_logger(__name__)


class MCPGovernanceManager:
    """Manages governance configuration for discovered MCP tools.

    Responsibilities:
    - Check if MCP tool exists in tools.yaml
    - Auto-generate template entry if missing
    - Preserve user customizations on subsequent discoveries
    - Infer risk levels from tool names
    - Provide description overrides for better LLM tool selection
    """

    def __init__(self):
        """Initialize governance manager."""
        self.tools_config_path = settings.governance_config_path / "tools.yaml"

        if not self.tools_config_path.exists():
            raise FileNotFoundError(f"Governance config not found: {self.tools_config_path}")

        # Cache the config for description lookups
        self._config_cache: dict[str, Any] | None = None

    def get_description_override(self, tool_name: str) -> str | None:
        """Get description override for a tool if configured.

        This allows improving tool descriptions to help LLM tool selection.
        Set `description_override` in tools.yaml for any MCP tool.

        Args:
            tool_name: Tool name with mcp_ prefix (e.g., 'mcp_perplexity_ask')

        Returns:
            Override description if configured, None otherwise.
        """
        if self._config_cache is None:
            with open(self.tools_config_path, "r") as f:
                self._config_cache = yaml.safe_load(f)

        tools_section = self._config_cache.get("tools", {})
        tool_config = tools_section.get(tool_name, {})
        return tool_config.get("description_override")

    def ensure_tool_configured(
        self,
        tool_name: str,
        tool_schema: dict[str, Any],
        inferred_risk_level: Literal["low", "medium", "high"],
    ) -> None:
        """Ensure MCP tool has governance entry, create template if missing.

        Args:
            tool_name: MCP tool name with mcp_ prefix (e.g., 'mcp_github_search')
            tool_schema: MCP tool schema from discovery
            inferred_risk_level: Risk level inferred from tool name
        """
        # Load existing config
        with open(self.tools_config_path, "r") as f:
            config = yaml.safe_load(f)

        # Check if tool already configured
        tools_section = config.get("tools", {})
        if tool_name in tools_section:
            log.debug("mcp_tool_already_configured", tool=tool_name)
            return

        # Generate template entry
        template = self._generate_template(
            tool_name=tool_name, tool_schema=tool_schema, inferred_risk_level=inferred_risk_level
        )

        # Append to config file
        self._append_to_config(tool_name, template)

        log.info("mcp_tool_governance_added", tool=tool_name, risk_level=template["risk_level"])

    def _generate_template(
        self,
        tool_name: str,
        tool_schema: dict[str, Any],
        inferred_risk_level: Literal["low", "medium", "high"],
    ) -> dict[str, Any]:
        """Generate default governance template for MCP tool.

        Args:
            tool_name: Tool name with mcp_ prefix
            tool_schema: MCP tool schema
            inferred_risk_level: Risk level from name analysis

        Returns:
            Template dict for YAML output
        """
        description = tool_schema.get("description", "")

        # Determine modes based on risk level
        if inferred_risk_level == "high":
            allowed_modes = ["NORMAL"]
            requires_approval = True
        elif inferred_risk_level == "medium":
            allowed_modes = ["NORMAL", "DEGRADED"]
            requires_approval = False
        else:  # low
            allowed_modes = ["NORMAL", "ALERT", "DEGRADED"]
            requires_approval = False

        return {
            "category": "mcp",
            "allowed_in_modes": allowed_modes,
            "risk_level": inferred_risk_level,
            "requires_approval": requires_approval,
            "_auto_discovered": datetime.now().isoformat(),
            "_description": description,
        }

    def _append_to_config(self, tool_name: str, template: dict[str, Any]) -> None:
        """Append tool template to config file, preserving formatting.

        Args:
            tool_name: Tool name with mcp_ prefix
            template: Template dict generated by _generate_template
        """
        with open(self.tools_config_path, "a") as f:
            # Add blank line before new entry
            f.write("\n")

            # Add comment with discovery timestamp and description
            f.write(f"  # Auto-discovered: {template['_auto_discovered']}\n")
            if template["_description"]:
                # Wrap long descriptions - clean up newlines and truncate
                desc = template["_description"].replace("\n", " ").strip()
                if len(desc) > 70:
                    desc = desc[:70] + "..."
                f.write(f"  # {desc}\n")

            # Write tool entry
            f.write(f"  {tool_name}:\n")
            f.write(f'    category: "{template["category"]}"\n')
            f.write(f"    allowed_in_modes: {template['allowed_in_modes']}\n")
            f.write(f'    risk_level: "{template["risk_level"]}"\n')
            f.write(f"    requires_approval: {str(template['requires_approval']).lower()}\n")

            # Add commented customization hints
            f.write("    # Customize as needed:\n")
            f.write("    # forbidden_paths: []\n")
            f.write("    # allowed_paths: []\n")
            f.write("    # timeout_seconds: 30\n")

        log.debug("mcp_tool_config_appended", tool=tool_name, path=str(self.tools_config_path))
